{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tiny-script-loader/index.js","webpack:///./node_modules/tiny-script-loader/loadScript.js","webpack:///./node_modules/tiny-script-loader/loadScriptPromised.js","webpack:///./src/third_party/analytics.js","webpack:///./src/sia.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","loadScript","loadScriptPromised","src","cb","attrs","firstScript","el","doc","document","createElement","getElementsByTagName","keys","forEach","async","onload","onerror","Error","parentNode","insertBefore","Promise","resolve","reject","_tracker","isEnabled","trackEvent","category","action","label","optValue","tracker","window","gtag","TRACKERS","GlobalSiteTag","ga","GA","_gaq","push","Legacy","getTracker","event","widgetAPI","SC","Widget","init","processIFrames","iframes","playlists","loop","iframe","hasAttribute","getAttribute","includes","length","playlist","attachSoundCloudAnalytics","TinyScriptLoader","element","existingSIAId","iframeURL","setAttribute","vo","widget","ENUM","Events","hasTimeout","currentTrackTitle","currentTrackId","tracks","READY","ERROR","PLAY_PROGRESS","playerData","id","soundId","relativePosition","msg","progress","Math","round","sanitizeProgress","progstep","scrubbed","title","setTrackProgress","setTimeout","getCurrentSound","data","PLAY","getSoundCloudTrackVO","started","finished","paused","PAUSE","SEEK","FINISH","list","fn"],"mappings":"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","file":"sia.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","exports.loadScript = require('./loadScript')\nexports.loadScriptPromised = require('./loadScriptPromised')\n","module.exports = function loadScript (src, cb, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  el = doc.createElement(tag)\n  firstScript = doc.getElementsByTagName(tag)[0]\n  if (attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      el[key] = attrs[key]\n    })\n  }\n  el.async = 1\n  el.src = src\n  el.onload = function () { cb() }\n  el.onerror = function () { cb(new Error('failed to load: ' + src)) }\n  firstScript.parentNode.insertBefore(el, firstScript)\n}\n","module.exports = function loadScriptPromised (src, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  return new Promise(function (resolve, reject) {\n    el = doc.createElement(tag)\n    firstScript = doc.getElementsByTagName(tag)[0]\n    if (attrs) {\n      Object.keys(attrs).forEach(function (key) {\n        el[key] = attrs[key]\n      })\n    }\n    el.async = 1\n    el.src = src\n    el.onload = function () { resolve() }\n    el.onerror = function () {\n      reject(new Error('failed to load: ' + src))\n    }\n    firstScript.parentNode.insertBefore(el, firstScript)\n  })\n}\n","const DEBUG = false;\n\nlet isEnabled = true,\n    _tracker;\n\n/**\n * Track an event. Google recommends the\n * action, category, label order of things, but the Analytics\n * dashboard orders them by category, then action.\n *\n * @param {string} category\n * @param {string} action\n * @param {string} label\n * @param {*=} optValue\n */\nfunction trackEvent( category, action, label, optValue )\n{\n    if ( !isEnabled )\n        return;\n\n    const tracker = getTracker();\n\n    if ( !tracker )\n        return;\n\n    if ( DEBUG ) {\n        console.info(\n            `Tracking Event: category \"${category}\" action \"${action}\" label \"${label}\" value \"${optValue}\"`\n        )\n    }\n    tracker.event( category, action, label, optValue );\n}\n\nfunction reset()\n{\n    isEnabled = true;\n    _tracker  = null;\n}\n\nexport { trackEvent, reset };\n\n/* internal methods */\n\n/**\n * There are many Google Analytics trackers available\n * this function acts as a factory to retrieve the appropriate tracker.\n * If no tracking code can be found, Analytics will be disabled.\n *\n * @returns {Object}\n */\nfunction getTracker() {\n\n    if ( _tracker )\n        return _tracker;\n\n    if ( typeof window.gtag === \"function\" ) {\n        _tracker = TRACKERS.GlobalSiteTag;\n    }\n    else if ( typeof window.ga === \"function\" ) {\n        _tracker = TRACKERS.GA;\n    }\n    else if ( \"_gaq\" in window && typeof window._gaq.push === \"function\" ) {\n        _tracker = TRACKERS.Legacy;\n    }\n\n    if ( _tracker )\n        return _tracker;\n\n    // no Google Analytics tracker code found, disable tracking\n\n    isEnabled = false;\n\n    return null;\n}\n\nconst TRACKERS = {\n    GlobalSiteTag: {\n        event( category, action, label, value ) {\n            window.gtag( \"event\", action, {\n                \"event_category\": category,\n                \"event_label\": label,\n                \"value\": value\n            });\n        }\n    },\n    GA: {\n        event( category, action, label, value ) {\n            window.ga( \"send\", \"event\", category, action, label );\n        }\n    },\n    Legacy: {\n        event( category, action, label, value ) {\n            window._gaq.push([\"_trackEvent\", category, action, label ]);\n        }\n    }\n};\n","import TinyScriptLoader from \"tiny-script-loader\";\nimport { trackEvent } from \"./third_party/analytics\";\n\nconst SOUNDCLOUD_API_URL       = \"https://w.soundcloud.com/player/api.js\";\nconst SOUNDCLOUD_EMBED         = \"soundcloud.com\"; // URL fragment to determine iframe widget embed\nconst ANALYTICS_EVENT_CATEGORY = \"SoundCloud\";\n\n// hold a reference to the Widget API\n// we do this upon load as loading subsequent SDK's from SoundCloud will overwrite the\n// global SC Object making the SC.Widget unavailable !!\n\nlet widgetAPI = \"SC\" in window && typeof window.SC.Widget === \"function\" ? window.SC.Widget : null;\n\n/**\n * Loads SoundCloud Widget SDK (if it wasn't globally available yet)\n * and automatically attaches Analytics handlers to all embedded\n * SoundCloud HTMLIFrameElements currently in the document\n *\n * @returns {Promise}\n */\nexport function init() {\n    return new Promise(( resolve, reject ) => {\n\n        // process all IFrames one by one and add event listeners and Analytics hooks\n\n        const processIFrames = () => {\n\n            // retrieve all <iframe> embeds and filter them by the SoundCloud URL\n            // we use older DOM methods instead of querySelectorAll() to provide\n            // a very simple backwards compatibility\n\n            const iframes   = document.getElementsByTagName( \"iframe\" );\n            const playlists = [];\n            loop( iframes, ( iframe ) => {\n                if ( iframe.hasAttribute( \"src\" ) && iframe.getAttribute( \"src\" ).includes( SOUNDCLOUD_EMBED )) {\n                    playlists.push( iframe );\n                }\n            });\n\n            // if no playlists were found, don't do anything.\n\n            if ( playlists.length > 0 ) {\n                loop( playlists, ( playlist ) => {\n                    attachSoundCloudAnalytics( playlist );\n                });\n            }\n            resolve();\n        };\n\n        // ensure the SoundCloud Widget API has been loaded\n        // after which the processing of the IFrames can start\n\n        if ( widgetAPI ) {\n            processIFrames();\n        } else {\n            TinyScriptLoader.loadScript( SOUNDCLOUD_API_URL, () => {\n                widgetAPI = widgetAPI || window.SC.Widget;\n                processIFrames();\n            }, reject );\n        }\n    });\n}\n\n/**\n * Attach event listeners and hooks into Analytics\n * to the provided HTMLIFrameElement\n *\n * @param {HTMLIFrameElement} element\n */\nexport function attachSoundCloudAnalytics( element ) {\n\n    if ( !element ) {\n        return;\n    }\n\n    // don't create a Widget TWICE for the same IFrame / IFrame src\n\n    const existingSIAId = element.getAttribute( \"data-sia\" );\n    const iframeURL = element.getAttribute( \"src\" );\n\n    if ( existingSIAId && existingSIAId === iframeURL ) {\n        return false;\n    }\n\n    // store a reference to the element being bound to a widget via SIA\n\n    element.setAttribute( \"data-sia\", iframeURL );\n\n    // wrap element in SC.Widget instance\n    const widget = widgetAPI( element );\n\n    const ENUM = widgetAPI.Events;\n\n    // we can have multiple playlists, all their individual data\n    // is stored inside the closure of this function without\n    // requiring pollution of external scope\n\n    let hasTimeout = false, currentTrackTitle = \"\", currentTrackId = 0, tracks = {}, vo;\n\n    // cache the id of the currently playing track as many events in the\n    // playlist can cause this to change (e.g. finish fires after which\n    // the currentSound is returned as the next track in the playlist queue...)\n    // we poll this at an INTERVAL to prevent overusing API calls\n\n    const INTERVAL = 2500;\n\n    widget.bind( ENUM.READY, () => {\n        // no need to track, can be used for debugging purposes\n    });\n\n    widget.bind( ENUM.ERROR, () => {\n        trackEvent( ANALYTICS_EVENT_CATEGORY, \"Error\", currentTrackTitle );\n    });\n\n    widget.bind( ENUM.PLAY_PROGRESS, ( playerData ) => {\n\n        if ( vo && vo.id === playerData.soundId )\n            setTrackProgress( vo, playerData );\n\n        if ( hasTimeout )\n            return;\n\n        hasTimeout = true;\n\n        setTimeout(() => {\n\n            hasTimeout = false;\n            widget.getCurrentSound(( data ) => {\n\n                // last id does not equal new id, update\n                // and clear the tracks store (if we go back\n                // to a previously played track, we can collect\n                // behavioural data for it again)\n\n                if ( currentTrackId !== data.id ) {\n                    currentTrackTitle = data.title;\n                    currentTrackId    = data.id;\n                    tracks = {};\n                }\n            });\n\n        }, ( currentTrackId === 0 ) ? 0 : INTERVAL );\n    });\n\n    widget.bind( ENUM.PLAY, () => {\n        widget.getCurrentSound(( data ) => {\n\n            currentTrackTitle = data.title;\n            currentTrackId    = data.id;\n\n            vo = getSoundCloudTrackVO( tracks, data.title, data.id );\n\n            if ( !vo.started || vo.finished ) {\n\n                vo.started  = true;\n                vo.finished = false;\n                vo.paused   = false;\n                vo.scrubbed = false;\n                vo.progress = 0;\n                vo.progstep = 0;\n\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback started\", currentTrackTitle );\n            }\n            else if ( vo.paused ) {\n                vo.paused = false;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback resumed\", currentTrackTitle );\n            }\n        });\n    });\n\n    // we do not invoke trackSoundCloudEvent() here as getCurrentSound() can have moved to the next song!\n\n    widget.bind( ENUM.PAUSE, () => {\n        vo = getSoundCloudTrackVO( tracks, currentTrackTitle, currentTrackId );\n\n        // do async check for current sound, if it is the same then\n        // we can treat the track as paused, if not then the pause\n        // was triggered either before the track finished playing\n        // or before the playlist queued another track\n        // TODO: this still triggers a pause when starting a\n        // track in a different widget API\n\n        widget.getCurrentSound(( data ) => {\n            if ( data.id === vo.id && !vo.finished ) {\n                vo.paused = true;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback paused\", currentTrackTitle );\n            }\n        });\n    });\n    widget.bind( ENUM.SEEK, ( playerData ) => {\n        vo = getSoundCloudTrackVO( tracks, currentTrackTitle, currentTrackId );\n\n        // only once per play\n\n        if ( vo.scrubbed )\n            return;\n\n        if ( !vo.paused && !vo.finished ) {\n            vo.scrubbed = true;\n            trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback scrubbed\", currentTrackTitle );\n        }\n    });\n    widget.bind( ENUM.FINISH, () => {\n        vo = getSoundCloudTrackVO( tracks, currentTrackTitle, currentTrackId );\n        if ( !vo.finished ) {\n            vo.finished = true;\n            const event = ( !vo.scrubbed ) ? \"Played in full\" : \"Played in full with scrubbing\";\n            trackEvent( ANALYTICS_EVENT_CATEGORY, event, currentTrackTitle );\n        }\n    });\n}\n\n/* internal methods */\n\n/**\n * Retrieves a Value Object associated with the playback\n * state of a specific SoundCloud track. If it hasn't been\n * created yet, it will create it inline.\n *\n * @param {Object} tracks data store for the tracks\n * @param {string} title of the track\n * @param {number} id identifier of the track\n * @returns {Object}\n */\nfunction getSoundCloudTrackVO( tracks, title, id ) {\n\n    if ( !tracks.hasOwnProperty( title )) {\n        tracks[ title ] = {\n            title:    title,    // track title, used as label for Google Analytics\n            id:       id,       // track unique identifier on SoundCloud\n            started:  false,    // whether track has started its playback\n            paused:   false,    // whether track playback is paused\n            scrubbed: false,    // whether track has been scrubbed during playback\n            finished: false,    // whether track has finished its playback, e.g. reached the end\n            progress: 0,        // current track playback progress (0 - 100 range)\n            progstep: 0         // the progress that has been tracked so far (4 steps, once every 25%)\n        };\n    }\n    else if ( tracks[ title ].id === 0 ) {\n        tracks[ title].id = id;\n    }\n    return tracks[ title ];\n}\n\n/**\n * Get the track playback progress (in percent)\n *\n * @param {Object} playerData progress data Object\n */\nfunction sanitizeProgress( playerData ) {\n    return Math.round( playerData.relativePosition * 100 );\n}\n\n/**\n * Updates the progress value of the given VO\n * This also broadcasts the progress every 25 % of the track playback\n *\n * @param {Object} vo SoundCloud Value Object\n * @param {Object} playerData progress data Object\n */\nfunction setTrackProgress( vo, playerData ) {\n\n    if ( typeof playerData.relativePosition !== \"number\" )\n        return;\n\n    vo.progress = sanitizeProgress( playerData );\n\n    // track once every 25 %\n\n    let msg;\n\n    if ( vo.progress >= 99 && vo.progstep < 4 ) {\n        msg = \"4/4\";\n        vo.progstep = 4;\n    }\n    else if ( vo.progress >= 75 && vo.progstep < 3 ) {\n        msg = \"3/4\";\n        vo.progstep = 3;\n    }\n    else if ( vo.progress >= 50 && vo.progstep < 2 ) {\n        msg = \"2/4\";\n        vo.progstep = 2;\n    }\n    else if ( vo.progress >= 25 && vo.progstep < 1 ) {\n        msg = \"1/4\";\n        vo.progstep = 1;\n    }\n\n    if ( typeof msg === \"string\" ) {\n        if ( vo.scrubbed ) {\n            msg += \" with scrubbing\";\n        }\n        trackEvent( ANALYTICS_EVENT_CATEGORY, `Progress ${msg}`, vo.title );\n    }\n}\n\n/**\n * Simple forEach() implementation that will\n * go back a few old IE versions...\n *\n * @param {NodeList|Array} list\n * @param {Function} fn function to execute on each list entry\n */\nfunction loop( list, fn ) {\n    for ( let i = 0, l = list.length; i < l; ++i ) {\n        fn( list[ i ]);\n    }\n}\n"],"sourceRoot":""}