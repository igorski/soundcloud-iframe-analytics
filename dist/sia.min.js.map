{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tiny-script-loader/index.js","webpack:///./src/analytics/Analytics.js","webpack:///./src/soundcloud/SoundCloud.js","webpack:///./src/index.js","webpack:///./node_modules/tiny-script-loader/loadScriptPromised.js","webpack:///./node_modules/tiny-script-loader/loadScript.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","loadScript","loadScriptPromised","DEBUG","_tracker","isEnabled","trackEvent","category","action","label","optValue","tracker","window","gtag","TRACKERS","GlobalSiteTag","ga","GA","_gaq","push","Legacy","getTracker","console","info","event","event_category","event_label","SOUNDCLOUD_API_URL","SOUNDCLOUD_EMBED","ANALYTICS_EVENT_CATEGORY","getSoundCloudTrackVO","tracks","id","started","paused","finished","loop","list","fn","length","onload","playlists","document","getElementsByTagName","iframe","hasAttribute","getAttribute","indexOf","tiny_script_loader","playlist","widget","vo","hasTimeout","currentId","w","bind","SC","Widget","Events","PLAY_PROGRESS","warn","setTimeout","getCurrentSound","data","title","PLAY","PAUSE","SEEK","FINISH","attachSoundCloudAnalytics","src","attrs","firstScript","el","doc","Promise","resolve","reject","createElement","keys","forEach","key","async","onerror","Error","parentNode","insertBefore","cb"],"mappings":"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","file":"sia.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","exports.loadScript = require('./loadScript')\nexports.loadScriptPromised = require('./loadScriptPromised')\n","const DEBUG = true;\n\nlet isEnabled = true,\n    _tracker;\n\n/**\n * Track an event. Google recommends the\n * action, category, label order of things, but the Analytics\n * dashboard orders them by category, then action.\n *\n * @param {string} category\n * @param {string} action\n * @param {string} label\n * @param {*=} optValue\n */\nfunction trackEvent( category, action, label, optValue )\n{\n    if ( !isEnabled )\n        return;\n\n    const tracker = getTracker();\n\n    if ( !tracker )\n        return;\n\n    if ( DEBUG ) {\n        console.info(\n            `Tracking Event: category \"${category}\" action \"${action}\" label \"${label}\" value \"${optValue}\"`\n        )\n    }\n    tracker.event( category, action, label, optValue );\n}\n\nexport { trackEvent };\n\n/* internal methods */\n\n/**\n * There are many Google Analytics trackers available\n * this function acts as a factory to retrieve the appropriate tracker.\n * If no tracking code can be found, Analytics will be disabled.\n *\n * @returns {Object}\n */\nfunction getTracker() {\n\n    if ( _tracker )\n        return _tracker;\n\n    if ( typeof window.gtag === \"function\" ) {\n        _tracker = TRACKERS.GlobalSiteTag;\n    }\n    else if ( typeof window.ga === \"function\" ) {\n        _tracker = TRACKERS.GA;\n    }\n    else if ( \"_gaq\" in window && typeof window._gaq.push === \"function\" ) {\n        _tracker = TRACKERS.Legacy;\n    }\n\n    if ( _tracker )\n        return _tracker;\n\n    // no Google Analytics tracker code found, disable tracking\n\n    isEnabled = false;\n\n    return null;\n}\n\nconst TRACKERS = {\n    GlobalSiteTag: {\n        event( category, action, label, value ) {\n            window.gtag( \"event\", action, {\n                \"event_category\": category,\n                \"event_label\": label,\n                \"value\": value\n            });\n        }\n    },\n    GA: {\n        event( category, action, label, value ) {\n            window.ga( \"send\", \"event\", category, action, label );\n        }\n    },\n    Legacy: {\n        event( category, action, label, value ) {\n            window._gaq.push([\"_trackEvent\", category, action, label ]);\n        }\n    }\n};\n","import * as TinyScriptLoader from \"tiny-script-loader\";\nimport { trackEvent } from '../analytics/Analytics';\n\nconst SOUNDCLOUD_API_URL       = \"https://w.soundcloud.com/player/api.js\";\nconst SOUNDCLOUD_EMBED         = \"soundcloud.com\"; // URL fragment to determine iframe widget embed\nconst ANALYTICS_EVENT_CATEGORY = \"SoundCloud\";\n\nfunction init() {\n\n    // retrieve all <iframe> embeds and filter them by the SoundCloud URL\n    // we use older DOM methods instead of querySelectorAll() to provide\n    // a very simple backwards compatibility\n\n    const iframes   = document.getElementsByTagName( \"iframe\" );\n    const playlists = [];\n    loop( iframes, ( iframe ) => {\n        if ( iframe.hasAttribute( \"src\" ) && iframe.getAttribute( \"src\" ).indexOf( SOUNDCLOUD_EMBED ) > -1 )\n            playlists.push( iframe );\n    });\n\n    // if no playlists were found, don't do anything.\n\n    if ( playlists.length === 0 )\n        return;\n\n    // load the SoundCloud Widget API\n\n    TinyScriptLoader.loadScript( SOUNDCLOUD_API_URL, () => {\n        if ( \"SC\" in window ) {\n            loop( playlists, ( playlist ) => {\n                const widget = SC.Widget( playlist );\n                attachSoundCloudAnalytics( widget );\n            });\n        }\n    });\n}\n\nexport { init };\n\n/* internal methods */\n\nfunction attachSoundCloudAnalytics( widget ) {\n\n    // we can have multiple playlists, all their individual data\n    // is stored inside the closure of this function without\n    // requiring pollution of external scope\n\n    let hasTimeout = false, currentId = \"\", tracks = {}, vo;\n\n    // cache the id of the currently playing track as many events in the\n    // playlist can cause this to change (e.g. finish fires after which\n    // the currentSound is returned as the next track in the playlist queue...)\n    // we poll this at an INTERVAL to prevent overusing API calls\n\n    const INTERVAL = 2500;\n    window.w = widget;\n    widget.bind( SC.Widget.Events.PLAY_PROGRESS, () => {\n               console.warn(\"Ppi\");\n        if ( hasTimeout )\n            return;\n\n        hasTimeout = true;\n\n        setTimeout(() => {\n\n            hasTimeout = false;\n            widget.getCurrentSound(( data ) => {\n\n                // last id does not equal new id, update\n                // and clear the tracks store (if we go back\n                // to a previously played track, we can collect\n                // behavioural data for it again)\n\n                if ( currentId !== data.title ) {\n                    currentId = data.title;\n                    tracks = {};\n                }\n            });\n\n        }, ( currentId.length === 0 ) ? 0 : INTERVAL );\n    });\n\n    widget.bind( SC.Widget.Events.PLAY, () => {\n        widget.getCurrentSound(( data ) => {\n\n            currentId = data.title;\n            vo = getSoundCloudTrackVO( tracks, data.title );\n\n            if ( !vo.started || vo.finished ) {\n                vo.started  = true;\n                vo.finished = false;\n                vo.paused   = false;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback started\", currentId );\n            }\n            else if ( vo.paused ) {\n                vo.paused = false;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback resumed\", currentId );\n            }\n        });\n    });\n\n    // we do not invoke trackSoundCloudEvent() here as getCurrentSound() can have moved to the next song!\n\n    widget.bind( SC.Widget.Events.PAUSE, () => {\n        vo = getSoundCloudTrackVO( tracks, currentId );\n\n        // do async check for current sound, if it is the same then\n        // we can treat the track as paused, if not then the pause\n        // was triggered either before the track finished playing\n        // or before the playlist queued another track\n        // TODO: this still triggers a pause when starting a\n        // track in a different widget API\n\n        widget.getCurrentSound(( data ) => {\n            if ( data.title === vo.id && !vo.finished ) {\n                vo.paused = true;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback paused\", currentId );\n            }\n        });\n    });\n    widget.bind( SC.Widget.Events.SEEK, () => {\n        vo = getSoundCloudTrackVO( tracks, currentId );\n        if ( !vo.paused && !vo.finished ) {\n            trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback scrubbed\", currentId );\n        }\n    });\n    widget.bind( SC.Widget.Events.FINISH, () => {\n        vo = getSoundCloudTrackVO( tracks, currentId );\n        if ( !vo.finished ) {\n            vo.finished = true;\n            trackEvent( ANALYTICS_EVENT_CATEGORY, \"Played in full\", currentId );\n        }\n    });\n}\n\n/**\n * Retrieves a Value Object associated with the playback\n * state of a specific SoundCloud track. If it hasn't been\n * created yet, it will create it inline.\n *\n * @param {Object} tracks data store for the tracks\n * @param {string} id identifier of the track\n * @returns {Object}\n */\nfunction getSoundCloudTrackVO( tracks, id ) {\n\n    if ( !tracks.hasOwnProperty( id )) {\n        tracks[ id ] = {\n            id: id,\n            started: false,\n            paused: false,\n            finished: false\n        };\n    }\n    return tracks[ id ];\n}\n\n/**\n * Simple forEach() implementation that will\n * go back a few old IE versions...\n *\n * @param {NodeList|Array} list\n * @param {Function} fn function to execute on each list entry\n */\nfunction loop( list, fn ) {\n    for ( let i = 0, l = list.length; i < l; ++i ) {\n        fn( list[ i ]);\n    }\n}\n","import { init } from './soundcloud/SoundCloud.js';\n\n// application bootstraps when the document has finished loading, voila.\n\nwindow.onload = init;\n","module.exports = function loadScriptPromised (src, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  return new Promise(function (resolve, reject) {\n    el = doc.createElement(tag)\n    firstScript = doc.getElementsByTagName(tag)[0]\n    if (attrs) {\n      Object.keys(attrs).forEach(function (key) {\n        el[key] = attrs[key]\n      })\n    }\n    el.async = 1\n    el.src = src\n    el.onload = function () { resolve() }\n    el.onerror = function () {\n      reject(new Error('failed to load: ' + src))\n    }\n    firstScript.parentNode.insertBefore(el, firstScript)\n  })\n}\n","module.exports = function loadScript (src, cb, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  el = doc.createElement(tag)\n  firstScript = doc.getElementsByTagName(tag)[0]\n  if (attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      el[key] = attrs[key]\n    })\n  }\n  el.async = 1\n  el.src = src\n  el.onload = function () { cb() }\n  el.onerror = function () { cb(new Error('failed to load: ' + src)) }\n  firstScript.parentNode.insertBefore(el, firstScript)\n}\n"],"sourceRoot":""}