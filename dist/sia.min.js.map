{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tiny-script-loader/index.js","webpack:///./src/analytics/Analytics.js","webpack:///./src/soundcloud/SoundCloud.js","webpack:///./src/index.js","webpack:///./node_modules/tiny-script-loader/loadScriptPromised.js","webpack:///./node_modules/tiny-script-loader/loadScript.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","loadScript","loadScriptPromised","DEBUG","isEnabled","_tracker","trackEvent","category","action","label","optValue","tracker","window","gtag","TRACKERS","GlobalSiteTag","ga","GA","_gaq","push","Legacy","getTracker","console","info","event","event_category","event_label","SOUNDCLOUD_API_URL","SOUNDCLOUD_EMBED","ANALYTICS_EVENT_CATEGORY","init","playlists","loop","document","getElementsByTagName","iframe","hasAttribute","getAttribute","indexOf","length","processIFrames","playlist","widget","ENUM","SC","Widget","Events","hasTimeout","currentTrackTitle","currentTrackId","tracks","vo","bind","READY","ERROR","PLAY_PROGRESS","playerData","id","soundId","relativePosition","progress","Math","round","msg","progstep","scrubbed","title","setTrackProgress","setTimeout","getCurrentSound","data","PLAY","getSoundCloudTrackVO","started","finished","paused","PAUSE","SEEK","FINISH","attachSoundCloudAnalytics","tiny_script_loader","list","fn","addEventListener","readyHandler","removeEventListener","src","attrs","firstScript","el","doc","Promise","resolve","reject","createElement","keys","forEach","key","async","onload","onerror","Error","parentNode","insertBefore","cb"],"mappings":"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","file":"sia.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","exports.loadScript = require('./loadScript')\nexports.loadScriptPromised = require('./loadScriptPromised')\n","const DEBUG = false;\n\nlet isEnabled = true,\n    _tracker;\n\n/**\n * Track an event. Google recommends the\n * action, category, label order of things, but the Analytics\n * dashboard orders them by category, then action.\n *\n * @param {string} category\n * @param {string} action\n * @param {string} label\n * @param {*=} optValue\n */\nfunction trackEvent( category, action, label, optValue )\n{\n    if ( !isEnabled )\n        return;\n\n    const tracker = getTracker();\n\n    if ( !tracker )\n        return;\n\n    if ( DEBUG ) {\n        console.info(\n            `Tracking Event: category \"${category}\" action \"${action}\" label \"${label}\" value \"${optValue}\"`\n        )\n    }\n    tracker.event( category, action, label, optValue );\n}\n\nfunction reset()\n{\n    isEnabled = true;\n    _tracker  = null;\n}\n\nexport { trackEvent, reset };\n\n/* internal methods */\n\n/**\n * There are many Google Analytics trackers available\n * this function acts as a factory to retrieve the appropriate tracker.\n * If no tracking code can be found, Analytics will be disabled.\n *\n * @returns {Object}\n */\nfunction getTracker() {\n\n    if ( _tracker )\n        return _tracker;\n\n    if ( typeof window.gtag === \"function\" ) {\n        _tracker = TRACKERS.GlobalSiteTag;\n    }\n    else if ( typeof window.ga === \"function\" ) {\n        _tracker = TRACKERS.GA;\n    }\n    else if ( \"_gaq\" in window && typeof window._gaq.push === \"function\" ) {\n        _tracker = TRACKERS.Legacy;\n    }\n\n    if ( _tracker )\n        return _tracker;\n\n    // no Google Analytics tracker code found, disable tracking\n\n    isEnabled = false;\n\n    return null;\n}\n\nconst TRACKERS = {\n    GlobalSiteTag: {\n        event( category, action, label, value ) {\n            window.gtag( \"event\", action, {\n                \"event_category\": category,\n                \"event_label\": label,\n                \"value\": value\n            });\n        }\n    },\n    GA: {\n        event( category, action, label, value ) {\n            window.ga( \"send\", \"event\", category, action, label );\n        }\n    },\n    Legacy: {\n        event( category, action, label, value ) {\n            window._gaq.push([\"_trackEvent\", category, action, label ]);\n        }\n    }\n};\n","import * as TinyScriptLoader from \"tiny-script-loader\";\nimport { trackEvent } from '../analytics/Analytics';\n\nconst SOUNDCLOUD_API_URL       = \"https://w.soundcloud.com/player/api.js\";\nconst SOUNDCLOUD_EMBED         = \"soundcloud.com\"; // URL fragment to determine iframe widget embed\nconst ANALYTICS_EVENT_CATEGORY = \"SoundCloud\";\n\n/**\n * Automatically attach Analytics handlers to all embedded\n * SoundCloud <iframe> Elements currently in the page\n */\nfunction init() {\n\n    // retrieve all <iframe> embeds and filter them by the SoundCloud URL\n    // we use older DOM methods instead of querySelectorAll() to provide\n    // a very simple backwards compatibility\n\n    const iframes   = document.getElementsByTagName( \"iframe\" );\n    const playlists = [];\n    loop( iframes, ( iframe ) => {\n        if ( iframe.hasAttribute( \"src\" ) && iframe.getAttribute( \"src\" ).indexOf( SOUNDCLOUD_EMBED ) > -1 )\n            playlists.push( iframe );\n    });\n\n    // if no playlists were found, don't do anything.\n\n    if ( playlists.length === 0 )\n        return;\n\n    // process all IFrames one by one and add event listeners and Analytics hooks\n\n    const processIFrames = () => {\n        loop( playlists, ( playlist ) => {\n            const widget = SC.Widget( playlist );\n            attachSoundCloudAnalytics( widget );\n        });\n    };\n\n    // ensure the SoundCloud Widget API has been loaded\n    // after which the processing of the IFrames can start\n\n    if ( \"SC\" in window && typeof SC.Widget === \"function\" ) {\n        processIFrames();\n    }\n    else {\n        TinyScriptLoader.loadScript( SOUNDCLOUD_API_URL, processIFrames );\n    }\n}\n\n/**\n * Attach event listeners and hooks into Analytics\n * to a provided instance of SC.Widget\n *\n * @param {SC.Widget} widget\n */\nfunction attachSoundCloudAnalytics( widget ) {\n\n    const ENUM = SC.Widget.Events;\n\n    // we can have multiple playlists, all their individual data\n    // is stored inside the closure of this function without\n    // requiring pollution of external scope\n\n    let hasTimeout = false, currentTrackTitle = \"\", currentTrackId = 0, tracks = {}, vo;\n\n    // cache the id of the currently playing track as many events in the\n    // playlist can cause this to change (e.g. finish fires after which\n    // the currentSound is returned as the next track in the playlist queue...)\n    // we poll this at an INTERVAL to prevent overusing API calls\n\n    const INTERVAL = 2500;\n\n    widget.bind( ENUM.READY, () => {\n        // no need to track, can be used for debugging purposes\n    });\n\n    widget.bind( ENUM.ERROR, () => {\n        trackEvent( ANALYTICS_EVENT_CATEGORY, \"Error\", currentTrackTitle );\n    });\n\n    widget.bind( ENUM.PLAY_PROGRESS, ( playerData ) => {\n\n        if ( vo && vo.id === playerData.soundId )\n            setTrackProgress( vo, playerData );\n\n        if ( hasTimeout )\n            return;\n\n        hasTimeout = true;\n\n        setTimeout(() => {\n\n            hasTimeout = false;\n            widget.getCurrentSound(( data ) => {\n\n                // last id does not equal new id, update\n                // and clear the tracks store (if we go back\n                // to a previously played track, we can collect\n                // behavioural data for it again)\n\n                if ( currentTrackId !== data.id ) {\n                    currentTrackTitle = data.title;\n                    currentTrackId    = data.id;\n                    tracks = {};\n                }\n            });\n\n        }, ( currentTrackId === 0 ) ? 0 : INTERVAL );\n    });\n\n    widget.bind( ENUM.PLAY, () => {\n        widget.getCurrentSound(( data ) => {\n\n            currentTrackTitle = data.title;\n            currentTrackId    = data.id;\n\n            vo = getSoundCloudTrackVO( tracks, data.title, data.id );\n\n            if ( !vo.started || vo.finished ) {\n\n                vo.started  = true;\n                vo.finished = false;\n                vo.paused   = false;\n                vo.scrubbed = false;\n                vo.progress = 0;\n                vo.progstep = 0;\n\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback started\", currentTrackTitle );\n            }\n            else if ( vo.paused ) {\n                vo.paused = false;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback resumed\", currentTrackTitle );\n            }\n        });\n    });\n\n    // we do not invoke trackSoundCloudEvent() here as getCurrentSound() can have moved to the next song!\n\n    widget.bind( ENUM.PAUSE, () => {\n        vo = getSoundCloudTrackVO( tracks, currentTrackTitle, currentTrackId );\n\n        // do async check for current sound, if it is the same then\n        // we can treat the track as paused, if not then the pause\n        // was triggered either before the track finished playing\n        // or before the playlist queued another track\n        // TODO: this still triggers a pause when starting a\n        // track in a different widget API\n\n        widget.getCurrentSound(( data ) => {\n            if ( data.id === vo.id && !vo.finished ) {\n                vo.paused = true;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback paused\", currentTrackTitle );\n            }\n        });\n    });\n    widget.bind( ENUM.SEEK, () => {\n        vo = getSoundCloudTrackVO( tracks, currentTrackTitle, currentTrackId );\n        if ( !vo.scrubbed && !vo.paused && !vo.finished ) {\n            vo.scrubbed = true;\n            trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback scrubbed\", currentTrackTitle );\n        }\n    });\n    widget.bind( ENUM.FINISH, () => {\n        vo = getSoundCloudTrackVO( tracks, currentTrackTitle, currentTrackId );\n        if ( !vo.finished ) {\n            vo.finished = true;\n            const event = ( !vo.scrubbed ) ? \"Played in full\" : \"Played in full with scrubbing\";\n            trackEvent( ANALYTICS_EVENT_CATEGORY, event, currentTrackTitle );\n        }\n    });\n}\n\nexport { init, attachSoundCloudAnalytics };\n\n/* internal methods */\n\n/**\n * Retrieves a Value Object associated with the playback\n * state of a specific SoundCloud track. If it hasn't been\n * created yet, it will create it inline.\n *\n * @param {Object} tracks data store for the tracks\n * @param {string} title of the track\n * @param {number} id identifier of the track\n * @returns {Object}\n */\nfunction getSoundCloudTrackVO( tracks, title, id ) {\n\n    if ( !tracks.hasOwnProperty( title )) {\n        tracks[ title ] = {\n            title:    title,    // track title, used as label for Google Analytics\n            id:       id,       // track unique identifier on SoundCloud\n            started:  false,    // whether track has started its playback\n            paused:   false,    // whether track playback is paused\n            scrubbed: false,    // whether track has been scrubbed during playback\n            finished: false,    // whether track has finished its playback, e.g. reached the end\n            progress: 0,        // current track playback progress (0 - 100 range)\n            progstep: 0         // the progress that has been tracked so far (4 steps, once every 25%)\n        };\n    }\n    else if ( tracks[ title ].id === 0 ) {\n        tracks[ title].id = id;\n    }\n    return tracks[ title ];\n}\n\n/**\n * Get the track playback progress (in percent)\n *\n * @param {Object} vo SoundCloud Value Object\n * @param {Object} playerData progress data Object\n */\nfunction setTrackProgress( vo, playerData ) {\n\n    if ( typeof playerData.relativePosition !== \"number\" )\n        return;\n\n    vo.progress = Math.round( playerData.relativePosition * 100 );\n\n    // track once every 25 %\n\n    let doTrack = false, msg;\n\n    if ( vo.progress >= 99 && vo.progstep < 4 ) {\n        msg = \"4/4\";\n        vo.progstep = 4;\n    }\n    else if ( vo.progress >= 75 && vo.progstep < 3 ) {\n        msg = \"3/4\";\n        vo.progstep = 3;\n    }\n    else if ( vo.progress >= 50 && vo.progstep < 2 ) {\n        msg = \"2/4\";\n        vo.progstep = 2;\n    }\n    else if ( vo.progress >= 25 && vo.progstep < 1 ) {\n        msg = \"1/4\";\n        vo.progstep = 1;\n    }\n\n    if ( typeof msg === \"string\" ) {\n        if ( vo.scrubbed ) {\n            msg += \" with scrubbing\";\n        }\n        trackEvent( ANALYTICS_EVENT_CATEGORY, `Progress ${msg}`, vo.title );\n    }\n}\n\n/**\n * Simple forEach() implementation that will\n * go back a few old IE versions...\n *\n * @param {NodeList|Array} list\n * @param {Function} fn function to execute on each list entry\n */\nfunction loop( list, fn ) {\n    for ( let i = 0, l = list.length; i < l; ++i ) {\n        fn( list[ i ]);\n    }\n}\n","import { init } from './soundcloud/SoundCloud.js';\n\n// initialize the code as soon as the HTML Document is ready\n\nconst READY_EVENT  = \"DOMContentLoaded\";\nconst readyHandler = () => {\n    init();\n    document.removeEventListener( READY_EVENT, readyHandler );\n};\ndocument.addEventListener( READY_EVENT, readyHandler );\n\n","module.exports = function loadScriptPromised (src, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  return new Promise(function (resolve, reject) {\n    el = doc.createElement(tag)\n    firstScript = doc.getElementsByTagName(tag)[0]\n    if (attrs) {\n      Object.keys(attrs).forEach(function (key) {\n        el[key] = attrs[key]\n      })\n    }\n    el.async = 1\n    el.src = src\n    el.onload = function () { resolve() }\n    el.onerror = function () {\n      reject(new Error('failed to load: ' + src))\n    }\n    firstScript.parentNode.insertBefore(el, firstScript)\n  })\n}\n","module.exports = function loadScript (src, cb, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  el = doc.createElement(tag)\n  firstScript = doc.getElementsByTagName(tag)[0]\n  if (attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      el[key] = attrs[key]\n    })\n  }\n  el.async = 1\n  el.src = src\n  el.onload = function () { cb() }\n  el.onerror = function () { cb(new Error('failed to load: ' + src)) }\n  firstScript.parentNode.insertBefore(el, firstScript)\n}\n"],"sourceRoot":""}