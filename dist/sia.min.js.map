{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tiny-script-loader/index.js","webpack:///./src/analytics/Analytics.js","webpack:///./src/soundcloud/SoundCloud.js","webpack:///./src/index.js","webpack:///./node_modules/tiny-script-loader/loadScriptPromised.js","webpack:///./node_modules/tiny-script-loader/loadScript.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","loadScript","loadScriptPromised","DEBUG","isEnabled","_tracker","trackEvent","category","action","label","optValue","tracker","window","gtag","TRACKERS","GlobalSiteTag","ga","GA","_gaq","push","Legacy","getTracker","console","info","event","event_category","event_label","SOUNDCLOUD_API_URL","SOUNDCLOUD_EMBED","ANALYTICS_EVENT_CATEGORY","init","playlists","loop","document","getElementsByTagName","iframe","hasAttribute","getAttribute","indexOf","length","tiny_script_loader","playlist","widget","SC","Widget","requestAnimationFrame","ENUM","Events","hasTimeout","currentId","tracks","vo","bind","READY","ERROR","PLAY_PROGRESS","setTimeout","getCurrentSound","data","title","PLAY","getSoundCloudTrackVO","started","finished","paused","PAUSE","id","SEEK","FINISH","list","fn","addEventListener","readyHandler","removeEventListener","src","attrs","firstScript","el","doc","Promise","resolve","reject","createElement","keys","forEach","key","async","onload","onerror","Error","parentNode","insertBefore","cb"],"mappings":"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","file":"sia.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","exports.loadScript = require('./loadScript')\nexports.loadScriptPromised = require('./loadScriptPromised')\n","const DEBUG = false;\n\nlet isEnabled = true,\n    _tracker;\n\n/**\n * Track an event. Google recommends the\n * action, category, label order of things, but the Analytics\n * dashboard orders them by category, then action.\n *\n * @param {string} category\n * @param {string} action\n * @param {string} label\n * @param {*=} optValue\n */\nfunction trackEvent( category, action, label, optValue )\n{\n    if ( !isEnabled )\n        return;\n\n    const tracker = getTracker();\n\n    if ( !tracker )\n        return;\n\n    if ( DEBUG ) {\n        console.info(\n            `Tracking Event: category \"${category}\" action \"${action}\" label \"${label}\" value \"${optValue}\"`\n        )\n    }\n    tracker.event( category, action, label, optValue );\n}\n\nfunction reset()\n{\n    isEnabled = true;\n    _tracker  = null;\n}\n\nexport { trackEvent, reset };\n\n/* internal methods */\n\n/**\n * There are many Google Analytics trackers available\n * this function acts as a factory to retrieve the appropriate tracker.\n * If no tracking code can be found, Analytics will be disabled.\n *\n * @returns {Object}\n */\nfunction getTracker() {\n\n    if ( _tracker )\n        return _tracker;\n\n    if ( typeof window.gtag === \"function\" ) {\n        _tracker = TRACKERS.GlobalSiteTag;\n    }\n    else if ( typeof window.ga === \"function\" ) {\n        _tracker = TRACKERS.GA;\n    }\n    else if ( \"_gaq\" in window && typeof window._gaq.push === \"function\" ) {\n        _tracker = TRACKERS.Legacy;\n    }\n\n    if ( _tracker )\n        return _tracker;\n\n    // no Google Analytics tracker code found, disable tracking\n\n    isEnabled = false;\n\n    return null;\n}\n\nconst TRACKERS = {\n    GlobalSiteTag: {\n        event( category, action, label, value ) {\n            window.gtag( \"event\", action, {\n                \"event_category\": category,\n                \"event_label\": label,\n                \"value\": value\n            });\n        }\n    },\n    GA: {\n        event( category, action, label, value ) {\n            window.ga( \"send\", \"event\", category, action, label );\n        }\n    },\n    Legacy: {\n        event( category, action, label, value ) {\n            window._gaq.push([\"_trackEvent\", category, action, label ]);\n        }\n    }\n};\n","import * as TinyScriptLoader from \"tiny-script-loader\";\nimport { trackEvent } from '../analytics/Analytics';\n\nconst SOUNDCLOUD_API_URL       = \"https://w.soundcloud.com/player/api.js\";\nconst SOUNDCLOUD_EMBED         = \"soundcloud.com\"; // URL fragment to determine iframe widget embed\nconst ANALYTICS_EVENT_CATEGORY = \"SoundCloud\";\n\n/**\n * Automatically attach Analytics handlers to all embedded\n * SoundCloud <iframe> Elements currently in the page\n */\nfunction init() {\n\n    // retrieve all <iframe> embeds and filter them by the SoundCloud URL\n    // we use older DOM methods instead of querySelectorAll() to provide\n    // a very simple backwards compatibility\n\n    const iframes   = document.getElementsByTagName( \"iframe\" );\n    const playlists = [];\n    loop( iframes, ( iframe ) => {\n        if ( iframe.hasAttribute( \"src\" ) && iframe.getAttribute( \"src\" ).indexOf( SOUNDCLOUD_EMBED ) > -1 )\n            playlists.push( iframe );\n    });\n\n    // if no playlists were found, don't do anything.\n\n    if ( playlists.length === 0 )\n        return;\n\n    // load the SoundCloud Widget API\n\n    TinyScriptLoader.loadScript( SOUNDCLOUD_API_URL, () => {\n        if ( \"SC\" in window ) {\n            loop( playlists, ( playlist ) => {\n                const widget = SC.Widget( playlist );\n                window.requestAnimationFrame( attachSoundCloudAnalytics.bind( window, widget ));\n            });\n        }\n    });\n}\n\n/**\n * Attach event listeners and hooks into Analytics\n * to a provided instance of SC.Widget\n *\n * @param {SC.Widget} widget\n */\nfunction attachSoundCloudAnalytics( widget ) {\n\n    const ENUM = SC.Widget.Events;\n\n    // we can have multiple playlists, all their individual data\n    // is stored inside the closure of this function without\n    // requiring pollution of external scope\n\n    let hasTimeout = false, currentId = \"\", tracks = {}, vo;\n\n    // cache the id of the currently playing track as many events in the\n    // playlist can cause this to change (e.g. finish fires after which\n    // the currentSound is returned as the next track in the playlist queue...)\n    // we poll this at an INTERVAL to prevent overusing API calls\n\n    const INTERVAL = 2500;\n\n    widget.bind( ENUM.READY, () => {\n        // no need to track, can be used for debugging purposes\n    });\n\n    widget.bind( ENUM.ERROR, () => {\n        trackEvent( ANALYTICS_EVENT_CATEGORY, \"Error\", currentId );\n    });\n\n    widget.bind( ENUM.PLAY_PROGRESS, () => {\n\n        if ( hasTimeout )\n            return;\n\n        hasTimeout = true;\n\n        setTimeout(() => {\n\n            hasTimeout = false;\n            widget.getCurrentSound(( data ) => {\n\n                // last id does not equal new id, update\n                // and clear the tracks store (if we go back\n                // to a previously played track, we can collect\n                // behavioural data for it again)\n\n                if ( currentId !== data.title ) {\n                    currentId = data.title;\n                    tracks = {};\n                }\n            });\n\n        }, ( currentId.length === 0 ) ? 0 : INTERVAL );\n    });\n\n    widget.bind( ENUM.PLAY, () => {\n        widget.getCurrentSound(( data ) => {\n\n            currentId = data.title;\n            vo = getSoundCloudTrackVO( tracks, data.title );\n\n            if ( !vo.started || vo.finished ) {\n                vo.started  = true;\n                vo.finished = false;\n                vo.paused   = false;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback started\", currentId );\n            }\n            else if ( vo.paused ) {\n                vo.paused = false;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback resumed\", currentId );\n            }\n        });\n    });\n\n    // we do not invoke trackSoundCloudEvent() here as getCurrentSound() can have moved to the next song!\n\n    widget.bind( ENUM.PAUSE, () => {\n        vo = getSoundCloudTrackVO( tracks, currentId );\n\n        // do async check for current sound, if it is the same then\n        // we can treat the track as paused, if not then the pause\n        // was triggered either before the track finished playing\n        // or before the playlist queued another track\n        // TODO: this still triggers a pause when starting a\n        // track in a different widget API\n\n        widget.getCurrentSound(( data ) => {\n            if ( data.title === vo.id && !vo.finished ) {\n                vo.paused = true;\n                trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback paused\", currentId );\n            }\n        });\n    });\n    widget.bind( ENUM.SEEK, () => {\n        vo = getSoundCloudTrackVO( tracks, currentId );\n        if ( !vo.paused && !vo.finished ) {\n            trackEvent( ANALYTICS_EVENT_CATEGORY, \"Playback scrubbed\", currentId );\n        }\n    });\n    widget.bind( ENUM.FINISH, () => {\n        vo = getSoundCloudTrackVO( tracks, currentId );\n        if ( !vo.finished ) {\n            vo.finished = true;\n            trackEvent( ANALYTICS_EVENT_CATEGORY, \"Played in full\", currentId );\n        }\n    });\n}\n\nexport { init, attachSoundCloudAnalytics };\n\n/* internal methods */\n\n/**\n * Retrieves a Value Object associated with the playback\n * state of a specific SoundCloud track. If it hasn't been\n * created yet, it will create it inline.\n *\n * @param {Object} tracks data store for the tracks\n * @param {string} id identifier of the track\n * @returns {Object}\n */\nfunction getSoundCloudTrackVO( tracks, id ) {\n\n    if ( !tracks.hasOwnProperty( id )) {\n        tracks[ id ] = {\n            id: id,\n            started: false,\n            paused: false,\n            finished: false\n        };\n    }\n    return tracks[ id ];\n}\n\n/**\n * Simple forEach() implementation that will\n * go back a few old IE versions...\n *\n * @param {NodeList|Array} list\n * @param {Function} fn function to execute on each list entry\n */\nfunction loop( list, fn ) {\n    for ( let i = 0, l = list.length; i < l; ++i ) {\n        fn( list[ i ]);\n    }\n}\n","import { init } from './soundcloud/SoundCloud.js';\n\n// initialize the code as soon as the HTML Document is ready\n\nconst READY_EVENT  = \"DOMContentLoaded\";\nconst readyHandler = () => {\n    init();\n    document.removeEventListener( READY_EVENT, readyHandler );\n};\ndocument.addEventListener( READY_EVENT, readyHandler );\n\n","module.exports = function loadScriptPromised (src, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  return new Promise(function (resolve, reject) {\n    el = doc.createElement(tag)\n    firstScript = doc.getElementsByTagName(tag)[0]\n    if (attrs) {\n      Object.keys(attrs).forEach(function (key) {\n        el[key] = attrs[key]\n      })\n    }\n    el.async = 1\n    el.src = src\n    el.onload = function () { resolve() }\n    el.onerror = function () {\n      reject(new Error('failed to load: ' + src))\n    }\n    firstScript.parentNode.insertBefore(el, firstScript)\n  })\n}\n","module.exports = function loadScript (src, cb, attrs) {\n  var doc = document\n  var tag = 'script'\n  var firstScript\n  var el\n  el = doc.createElement(tag)\n  firstScript = doc.getElementsByTagName(tag)[0]\n  if (attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      el[key] = attrs[key]\n    })\n  }\n  el.async = 1\n  el.src = src\n  el.onload = function () { cb() }\n  el.onerror = function () { cb(new Error('failed to load: ' + src)) }\n  firstScript.parentNode.insertBefore(el, firstScript)\n}\n"],"sourceRoot":""}